"""
C. Приснится же такое...

	Все языки	C++20 (GCC 14.1)	C++20 (Clang 18.1.6)
Ограничение времени	3 секунды	2 секунды	2 секунды
Ограничение памяти	512Mb	512Mb	512Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Наконец-то с царством Морфея удалось наладить дипломатические отношения! Первым делом в магазины поступили самые корректные и полные сонники, составленные в сотрудничестве с главными сномагами царства.
Ваш близкий друг Тирания Вампадур купила такой сонник одной из первых. Но тут же её ждало разочарование. Оказалось, что некоторые сны образуют целую последовательность сюжетов, которую надо интерпретировать только целиком.
И у Тирании оказалась именно такая ситуация. Когда-то давно ей приснилось двоичное дерево из N вершин, занумерованных целыми числами от 1 до N.
Вершина 1 являлась корнем. У каждой вершины v было до двух сыновей: левый имел номер 2⋅v, правый — 2⋅v+1 (при условии, что их номера не превосходили N). Таким образом, зная число N, дерево можно было однозначно восстановить.
Но, к сожалению, следующие Q ночей Тирании снились похожие сны: одна из вершин дерева v менялась местами с её предком (если v была корнем дерева, то ничего не происходило). Причем эти изменения переносились между снами, всё больше и больше изменяя оригинальное дерево.
Чтобы верно интерпретировать значение снов, Тирании нужно узнать итоговую структуру дерева после всех произошедших с ним изменений. Она просит вас помочь ей и по последовательности менявшихся вершин найти итоговую структуру дерева из её снов.
Понимая, что в этом деле важна точность, вы расспросили Тиранию насчет процесса обмена местами вершины v с её предком.
Введем обозначения:
•	p — предок вершины v, pp — предок вершины p (если таковые существуют);
•	vl — левый ребенок v, vr — правый ребенок v;
•	pl — левый ребенок p, pr — правый ребенок p.
В таком случае обмен задаётся следующими условиями:
•	Изменение предка: если p — левый ребенок вершины pp, то v становится левым ребенком pp, иначе — правым.
•	если v — левый ребенок вершины p, то:
1.	p становится левым ребенком v;
2.	vr остаётся правым ребенком v;
3.	vl становится левым ребенком p;
4.	pr остаётся правым ребенком p.

•	аналогично, если v — правый ребенок вершины p, то:
1.	p становится правым ребенком v;
2.	vl остаётся левым ребенком v;
3.	vr становится правым ребенком p;
4.	pl остаётся левым ребенком p.

Формат ввода
Первая строка содержит два целых числа N и Q (1≤N≤750;1≤Q≤106) — количество вершин в дереве и количество изменений, произошедших с деревом.
В следующей строке дано Q целых чисел v1, v2, …, vq (1≤vi≤N), где vi — номер вершины, обменявшейся местами со своим предком в i-ю ночь.
Формат вывода
В единственной строке через пробел требуется вывести номера вершин дерева после всех изменений в формате LVR, начиная с корня дерева.
Формат LVR(v) определяется рекурсивно для вершины v.
1.	если у вершины v есть левый ребенок lv, то сначала выводится всё поддерево lv в формате LVR(lv);
2.	выводится номер вершины v;
3.	если у вершины v есть правый ребенок rv, то выводится всё поддерево rv в формате LVR(rv);

Пример
Ввод
10 6
5 7 4 7 8 7
Вывод
7 10 5 2 8 4 9 1 6 3

Примечания
Объяснение примера строится из двух частей:
•	Рисунки, показывающие структуру дерева в каждом сне;
•	Текстовое пояснение к выводу на тест;
В тестовом примере дано дерево из 10 вершин:

Происходит 6 изменений с деревом:
1.	вершина 5 меняется с вершиной 2:

2.	вершина 7 меняется с вершиной 3:

"""
N, Q = map(int, input().split())

Qs = list(map(int, input().split()))

